---
pagetitle: GWAS
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE, purl=FALSE}
knitr::opts_chunk$set(error = FALSE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = "../course_files")
set.seed(123)
```

# Linkage disequilibrium

:::{.callout-tip}
#### Learning objectives

- Produce a set of uncorrelated variants using linkage disequilibrium pruning.
:::

```{r}
#| echo: false
#| eval: false

# this code can be used to simulate some data with LD structure
# to exemplify the clumping we may expect in GWAS
# at the moment it's here for our reference to tweak in future versions of this document
library(tidyverse)

set.seed(42)

simulate_ld_block <- function(n_individuals = 1000,
                              n_snps = 400,
                              rho = 0.95) {
  # Create AR(1) covariance matrix
  Sigma <- outer(1:n_snps, 1:n_snps, function(i, j) rho^abs(i - j))
  L <- chol(Sigma) # Cholesky decomposition

  # Generate multivariate normal and threshold to simulate genotypes
  Z <- matrix(rnorm(n_individuals * n_snps), nrow = n_individuals) %*% L

  # Convert to genotype-like values (0/1/2)
  maf <- runif(n_snps, 0.05, 0.5)
  genotypes <- matrix(0, nrow = n_individuals, ncol = n_snps)
  for (j in 1:n_snps) {
    probs <- c((1 - maf[j])^2, 2 * maf[j] * (1 - maf[j]), maf[j]^2)
    thresholds <- qnorm(cumsum(probs)[1:2])
    genotypes[, j] <- as.numeric(Z[, j] > thresholds[1]) + as.numeric(Z[, j] > thresholds[2])
  }

  genotypes
}

genotypes <- do.call(cbind, lapply(1:3, function(i) simulate_ld_block(n = 1000, n_snps = 100, rho = runif(1, 0.9, 0.95))))
colnames(genotypes) <- paste0("SNP", 1:ncol(genotypes))

# Simulate phenotype with two independent causal SNPs (SNP3 and SNP10)
effect_sizes <- rep(0, ncol(genotypes))
effect_sizes[125] <- 0.8
effect_sizes[150] <- 0.7

y <- genotypes %*% effect_sizes + rnorm(nrow(genotypes), 0, 1)

# Association test (linear regression)
assoc_p <- apply(genotypes, 2, function(g) summary(lm(y ~ g))$coef[2, 4])
assoc_b <- apply(genotypes, 2, function(g) summary(lm(y ~ g))$coef[2, 1])

assoc_df <- data.frame(
  SNP = 1:ncol(genotypes),
  Beta = assoc_b,
  P = assoc_p
)

# Pairwise LD (RÂ²) between SNPs
ld_matrix <- cor(genotypes)^2

assoc_df |>
  mutate(
    snp1_cor = ld_matrix[125, ],
    snp2_cor = ld_matrix[150, ]
  ) |>
  mutate(
    snp1_cor = ifelse(snp1_cor > 0.2, snp1_cor, 0),
    snp2_cor = ifelse(snp2_cor > 0.2, snp2_cor, 0)
  ) |>
  ggplot(aes(SNP, -log10(P))) +
  geom_point(aes(color = snp1_cor), size = 3) +
  geom_hline(yintercept = -log10(0.05 / 400), linetype = "dashed", color = "red") +
  theme_classic() +
  labs(
    x = "SNP position",
    y = "-log10(P-value)",
    color = "LD\nCorrelation"
  ) +
  scale_colour_gradient2(low = "darkblue", mid = "green", high = "red", limits = c(0, 1), midpoint = 0.5)
```

## LD prunning

Before proceeding with our next quality checks, we will perform a **linkage disequilibrium (LD) pruning** step.
This is a process that identifies variants that are in high linkage disequilibrium with each other, i.e. they are correlated and therefore provide redundant information.

Having a set of uncorrelated variants (i.e. in linkage equilibrium) is useful for many downstream analyses, such as principal component analysis (PCA) and estimates of individual inbreeding, which we will cover in the next chapter.

Identify variants in linkage equilibrium, we can use the `--indep-pairwise` option in PLINK. 
This option requires at least two options:

- **Window size**: how many neighbouring variants are considered at each step of the algorithm.
- **R-squared threshold**: how correlated the variants need to be in order to be prunned.

The algorithm then proceeds by sliding a window of the specified size across the genome, calculates the correlation for each pair of variants in that window, and prunes one of them if the correlation is above the specified threshold.

For our analysis, we will use a window size of 100 variants and an r-squared threshold of 0.8:

```bash
plink2 \
  --pfile data/plink/1000G_subset \
  --out results/1000G_subset \
  --chr 1-22 --hwe 0.001 keep-fewhe --maf 0.01 \
  --indep-pairwise 100 0.8
```

We have also restricted the analysis to chromosomes 1-22, as our main downstream analyses will only consider autosomes.
And we exclude sites that have excess heterozygosity (i.e. those that deviate from Hardy-Weinberg equilibrium) and low minor allele frequency (MAF < 1%).

The command above produces two files with the suffix `.prune.in` (variants that were kept by the algorithm, i.e. they should be largely uncorrelated) and `.prune.out` (the variants that were eliminated).

These files simply have a single column with the variant IDs:

```bash
head results/1000G_subset.prune.in
```

```
rs1463012642
rs1200541360
rs1472769893
rs1422057391
rs540466151
rs1478422777
rs1365462007
rs1385614989
rs1385058577
rs533630043
```

Now, in downstream analyses where we only want to use uncorrelated SNPs (e.g., PCA, sample inbreeding, relatedness), we can use the `--extract` option to use only the variants in the `.prune.in` file.
